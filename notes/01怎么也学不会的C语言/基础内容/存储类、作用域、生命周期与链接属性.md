---
title: 【C语言】存储类、作用域、生命周期与链接属性
date: 2020-02-12 19:31:00
tags: 
 - C
 - 存储类
 - 作用域
 - 生命周期
 - 链接属性
#categories: 
# - C
# declare: true
---

## 一、概念解析与内存映像

### 1.1 概念解析

1. 存储类：内存有多种管理方法：`stack、heap、.data、bss段、.text`等，一个变量的存储类属性就是描述这个变量存储在何种内存段中。
2. 作用域：用来描述一个符号(变量、函数等)起作用的范围。
3. 生命周期：用来描述变量的诞生(给变量分配内存)与消亡(回收分配的内存空间，此时变量无权访问此内存空间)
4. 链接属性：一个程序从源代码到最终的可执行程序需要经过编译链接，编译生成的.o目标文件中有很多符号(变量、函数等)及内存分段(`.data、.bss、.text`等)，其链接生成可执行程序的时候，就是把符号和对应的段给链接起来，此时就涉及到C语言符号中的三种链接属性：外链接属性、内链接属性、无链接属性
<!--more-->
### 1.2 linux下C程序的内存映像

内存段|存储的内容
:-|:-
代码段(文本段.text)|程序中的代码(函数)、字符串常量、单片机中const修饰的常量
只读数据段|gcc中const修饰的常量
数据段(.data)|显式初始化为非零的全局变量、显式初始化为非零的static局部变量
bss段|显式初始化为0和未显式初始化的全局变量、显式初始化为0或未显式初始化的static局部变量
堆(heap)|程序员自行malloc和free
栈(stack)|局部变量、函数传参
文件映射区|进程打开文件时将整个文件内容从硬盘读到进程的文件映射区，在内存中操作文件，操作完成后保存时将内存中的文件写入硬盘
内核映射区|操作系统内核程序映射的区域，对于4G内存的机器0xC0000000以上都是是OS内核的活动空间

### 1.3 OS下和裸机下C程序加载执行的差异

C语言的程序运行时对环境有一定的要求，单个人写的C程序是没法在内存中直接运行的，需要外部协助代码。这段外部协助代码用来构建C运行时的环境，又叫加载运行代码。

#### 有OS

加载运行代码由开发着写好存放在`OS`下，会自动添加到我们写的程序中，这段代码的主要作用是：给全局变量赋值、清`bss`段。即在`OS`运行程序时会自动完成重定位和清`bss`，所以：

>1. 数据段的全局变量或静态局部变量都是有非0的初值的，这些初值在main函数运行之前(重定位期间)就已经被初始化了
>2. C语言中未初始化的全局变量和`static`局部变量默认为0

#### 裸机

在`ARM`裸机下定义的全局变量初始化为0但是经常会不为0，这是因为程序员没在裸机的`start.S`中清`bss`段代码。这就说明在裸机中要程序员自己做加载运行代码(`start.S`中的重定位和清`bss`段)

## 二、存储类相关的关键字

### 2.1 auto

`auto`关键字在C语言中用来修饰静态局部变量，表示该局部变量为静态局部变量，该变量配在栈上。平时我们在函数内定义的普通局部变量都是`auto`的，只是省略了`auto`关键字（所以`auto`的存在感极低......）不过，在C11中auto有了很大的改动，详见以下文章：

[C11中的类型推导auto的使用](https://www.cnblogs.com/LyndonYoung/articles/5438436.html)
[【C++11】新特性——auto的使用](https://www.cnblogs.com/sollyu/p/4184515.html)

### 2.2 static

`static`关键字在C语言中有2种用法，这两种用法无任何关联

>1. 用来修饰局部变量，形成静态局部变量，分配在.data或bbs段
>2. 用来修饰全局变量，形成静态全局变量。链接属性为无链接属性

`static`局部变量与全局变量的比较如下：

比较类别|static局部变量|全局变量
:-|:-:|:-:
存储类|一样|一样
生命周期|一样|一样
作用域|代码块作用域，和普通局部变量一样|文件作用域，和函数一样
链接属性|无链接|外链接

[关于`stctic`这里有一篇高质量博文:c语言中static关键字用法详解](https://blog.csdn.net/guotianqing/article/details/79828100)

### 2.3 register

`register`修饰的变量编译器会尽量将其分配在寄存器中，大幅提升读写效率。所以`register`用来修饰那种反复高频率的使用变量，是一种极致的提升程序运行效率的手段。因为**寄存器数量有限**，所以一般不是非必要，不会定义`register`变量。同时，编译器只能承诺尽量将`register`修饰的变量放在寄存器中，不保证一定放在寄存器中。以下这篇博文比较了int变量和register int变量的速度：

[C语言寄存器变量register](https://blog.csdn.net/mouse_ts/article/details/45097603)

### 2.4 extern

`extern`主要用来声明全局变量，声明的目的主要是跨文件使用变量。因为C语言中编译是以单文件为单位的，当在一个.c文件中使用了同工程下另一.c文件中的变量时，就要用`extern`声明

[这有一篇精炼的总结：extern使用方法总结！](https://blog.csdn.net/qq_38880380/article/details/81474580)

### 2.5 volatile

`volatile`用来修饰一个变量，表示这个变量可以被编译器之外的东西改变。也就是说这个改变不是当前代码造成的，编译器在编译当前代码时无法预知。通常是以下三种情况的变量：

>1. 中断isr中引用的变量
>2. 多线程中共用的变量
>3. 硬件会更改的变量（通常是寄存器的值）

遇到以上三种变量都应用使用`volatile`修饰，告诉编译器这个变量值的改变它无法预知。编译器在遇到`volatile`修饰的变量时就不会对改变量的访问进行优化，就不会出现错误。

>* 编译器的优化在一般情况下非常好，可以帮助提升程序效率。但是在变量会被编译器想象之外的力量改变的情况下，此时如果编译器没有意识到而去优化则就会造成优化错误，带来执行时错误，而且这种错误很难被发现

[推荐文章：C语言中volatile关键字的作用](https://blog.csdn.net/tigerjibo/article/details/7427366)

### 2.6 restrict

`restrict`关键字是`c99`中才支持的和编译器行为特征有关的一个存储类关键字，只用来修饰指针，不能修饰普通变量。该关键字用于告知编译器，所有修改`该指针所指向内容的操作`全部都是基于该指针的，即不存在其它进行修改操作的途径，这样可以帮助编译器进行更好的代码优化，生成更有效率的汇编代码。

[详见参考文章：restrict关键字用法](http://blog.chinaunix.net/uid-22197900-id-359209.html)


## 三、作用域

作用域就是一个符号(变量、函数等)起作用的范围。

### 3.1 局部变量的代码块作用域

* 代码块可以理解为一对大括号{}括起来的部分，不等于函数，因为`if/for`等语法都有{}，可以说函数是由一个或多个代码块构成的
* 局部变量的代码块作用域，是说一个局部变量可以被访问和使用的范围仅限于声明这个局部变量的代码块中声明之后的部分，如

```cpp
void func1(void)
{
    int count = 0;
    printf("Hello World!\n");
    for(int i = 1; i < 10; i ++)
    {
        int a = 10;
        count ++;
    }
}
```

在上述函数中，`count`的作用域就是`line3~line10`，`i`的作用域仅限于`line5`，`a`的作用域为`line7~line9`；超过作用域去访问变量都是非法的，编译器会报未声明的错误！

### 3.2 函数名和全局变量的文件作用域

* 文件作用域的意思就是全局的访问权限，也就是说整个.c文件中都可以访问这些东西。
* 函数和全局变量的作用域是所在的整个.c文件之内声明之后的部分。

### 3.3 几个注意点

>1. 在`c89`标准中，所有的局部变量必须先定义在最前面，在变量定义之前不能有一句执行代码。在`c99`及以后的标准中，允许在当前代码段中使用前的任意位置声明并定义。
>2. 不管是局部变量、全局变量还是函数，使用前都要先声明/定义
>3. 局部变量的定义和声明是在一起的，全局变量和函数的定义和声明可以分开进行，也可以同时进行，如下代码

```cpp
#include <stdio.h>

extern int g_a; //声明
int g_b = 10;   //定义并声明
void func1(void);//声明
void func2(void)//定义并声明
{
    /*
        业务代码
    */
}
int main(void)
{
    int a;//定义并声明
    int b = 10;//定义并声明
    printf("g_a = %d\n", g_a);
    printf("g_b = %d\n", g_b);
    func1();
    func2();
    return 0;
}
void func1(void)//定义
{
    /*
        业务代码
    */
}
int g_a = 10;//定义
```

### 3.4 同名变量的掩蔽规则

编程时，不可避免会出现同名变量。变量同名后不一定会出错。

>* 如果两个同名变量作用域不同且没有交叠，这种情况下同名没有任何影响。
>* 如果两个同名变量作用域有交叠，C语言规定在作用域交叠范围内，作用域小的变量会掩蔽掉作用域大的

```cpp
#include <stdio.h>

int a = 10;

void func(void);

int main(void)
{
    int a = 5;
    for( ; ;)
    {
        int a = 0;
        printf("while in for, a = %d\n", a);
        break;
    }
    printf("only in main, a = %d\n",a);
    func();
    return 0;
}

void func(void)
{
    printf("when in func, a = %d\n", a);
}
```

![clipboard_20200214120413.png](https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F/clipboard_20200214120413.png)
我们可以看到，在不同的代码块中可以定义相同的变量，在变量作用域有交叠的时候，小的掩蔽大的

## 四、变量的生命周期

研究变量生命周期，有助于理解变量的行为特征。生命周期和存储类是紧密关联的

### 4.1 栈变量的生命周期

局部变量（栈变量）存储在栈上，生命周期是临时的，代码执行过程中按照需要去创建、使用、消亡该局部变量。比如一个函数内定义的局部变量，在这个函数每一次被调用时都会创建一次，然后使用，最后在函数返回的时候消亡。

### 4.2 堆变量的生命周期

堆内存空间是客观存在的，是由操作系统维护的（由堆管理器管理），程序只是去申请然后使用然后释放。堆内存从`malloc`申请时诞生，然后使用，直到`free`时消亡。

### 4.3 数据段、bss段变量的生命周期

全局变量的生命周期是永久的，在程序被执行时诞生，在程序终止时消亡。全局变量所占用的内存是不能被程序自己释放的，所以程序如果申请了过多的全局变量会导致这个程序一直占用大量内存。

### 4.4 代码段、只读段的生命周期

代码段和只读段的生命周期是永久的，有时候放在代码段的不只是代码，还有`const`类型的常量，字符串常量。（`const`类型的常量、字符串常量有时候放在`rodata`段，有时候放在代码段，取决于平台）

## 五、链接属性

### 5.1 C语言程序的组织架构

* 一个庞大、完整的一个C语言程序(linux内核、uboot等)是由多个.c文件和多个.h文件组成的
* 程序的生成过程可以简单理解为编译+链接。编译是为了将符号变成.o二进制的机器码格式，链接是为了将各个独立分开的二进制的函数链接起来形成一个整体的二进制可执行程序。
* **编译以文件为单位、链接以工程为单位**，编译器工作时是将所有源文件依次读进来，单个为单位进行编译的。链接的时候实际上是把第一步编译生成个单个的.o文件整体的输入，然后处理链接成一个可执行程序。

### 5.2 三种链接属性：外连接、内链接、无链接

1. 外链接属性，表示符号可以在整个程序范围内（可以跨文件）进行链接，如普通的函数和全局变量属于外连接。
2. 内链接属性，就是说符号只能在当前`c`文件内部范围内进行链接（就是不能在当前`c`文件外面的其他`c`文件中进行访问、链接）。`static`修饰的函数/全局变量属于内链接。
3. 无链接属性，就是说符号本身不参与链接，跟链接没关系。所有的局部变量（`auto、static`）和`inline`函数是无链接的

### 5.3 函数和全局变量的同名冲突

函数和全局变量是外部链接属性，每一个函数和全局变量将来在整个程序中所有的c文件都能被访问，因此在一个程序中的所有c文件中不能出现同名的函数/同名的全局变量。但是一个很大的工程中函数和全局变量名称不计其数，而且一个大工程是多人协作完成，很难保证不会重名，所以C语言引入了链接属性（在高级语言中的`namespace`和链接属性有异曲同工之妙）。

### 5.4 `static`修饰全局变量和函数

普通的（非静态）的函数/全局变量，默认的链接属性是外部的，`static`修饰的（静态）的函数/全局变量，链接属性是内部链接，如果一个同名的函数/全局变量在多个文件中定义，一定要加上`static`以限制链接属性。

## 六、结

存储类、作用域、生命周期和链接属性是相互关联的：**存储类决定生命周期，作用域决定链接属性**

符号|存储类|作用域|生命周期|链接属性
-|-|-|-|-
auto局部变量|stack|代码块|临时|无链接
static局部变量|.data/bss|代码块|永久|无链接
全局变量|.data/bss|文件|永久|外链接
函数|.text|文件|永久|外链接
inline函数|.text|文件|永久|无链接
static全局变量|.data/bss|文件|永久|内链接
static函数|.data/bss|文件|永久|内链接

>* `static`局部变量的地址由运行时环境在加载程序时确定，整个程序运行过程中唯一不变。
>* 静态局部变量其实就是作用域为代码块作用域且无连接的全局变量
>* 写程序尽量避免使用全局变量，尤其是非`static`类型的全局变量。能确定不会被其他文件引用的全局变量一定要`static`修饰
>* 宏和`inline`函数的链接属性为无链接
>* 为了避免`.h`文件被多个`.c`文件包含时全局变量重复定义的问题，全局变量应该定义在`.c`文件中并且在`.h`文件中声明
>* 在`b.c`中引用`a.c`中定义的全局变量/函数有2种方法：
>>1. 在`a.h`中声明该函数/全局变量，然后在`b.c`中`#include <a.h>`
>>2. 在`b.c`中使用`extern`显式声明要引用的函数/全局变量
>>* 其中第一种方法比较正式。