---
title: 栈(Stack)
date: 2020-01-31 22:08:49
tags: 
 - C
 - 指针
#categories: 
#declare: true
#Author：卢意
---


## 一、内存杂谈

### 1.1 程序执行需要内存支持

对程序来说，内存就是程序的立足之地（程序是被放在内存中运行的）；程序运行时需要内存来存储一些临时变脸
<!--more-->
### 1.2 内存管理

内存管理最终是由操作系统来完成的：

* 内存本身在物理上是一个硬件器件，由硬件系统提供
* 内存是由操作系统统一管理。为了内存管理既方便又合理，操作系统提供了多种机制让程序使用内存。这些机制彼此不同，各自有各自特点，程序根据实际情况选择某种方式获取内存（向操作系统申请使用权限）、使用内存、释放内存（向操作系统归还该内存的使用权限）

### 1.3 三种内存来源

1. 栈(stack)
2. 堆(heap)
3. 数据区(.data)

## 二、栈(stack)

栈是一种数据结构，C语言中使用栈来保存局部变量，是被发明出来管理内存的。

### 2.1 特点

#### 1.自动分配、回收

栈是操作系统自动管理的，程序员不需要手动干预，方便简单

#### 2.反复使用

栈内存在程序中是一块固定的空间，程序反复使用这一块空间

#### 3.先进后出FILO

 first in last out，入口和出口在一起，如图所示（图来自百度百科）
 ![18nrh4.png](https://s2.ax1x.com/2020/01/31/18nrh4.png)

#### 4.栈会溢出

操作系统事先给定了栈的大小，在函数中无穷尽地分配局部变量，肯定会爆栈

##### 爆栈测试代码

```cpp
#include <stdio.h>
void stack_overflow(void);
int main(void)
{
    stack_overflow();
    return 0;
}
void stack_overflow(void)
{
    int a = 0;
    stack_overflow();
}
```

##### 测试结果

![18CDb9.png](https://s2.ax1x.com/2020/01/31/18CDb9.png)

爆栈之后访问了不该访问的地址引发段错误。

#### 5.脏内存、临时性

栈由于反复使用，每次使用后程序不会去清理，因此分配到时保留原来的值（C语言中定义未初始化的局部变量时，值是随机的）。由此，为了避免不必要的麻烦，函数不能返回栈变量的指针（就相当于酒店的临时住宿地址不是家庭地址）

##### 测试代码

```cpp
#include <stdio.h>

int *func1(void)
{
    static int a = 1;
    return &a;
}

int *func2(void)
{
    int a = 1;
    return &a;
}

int main(void)
{
    int arr[5] = {10, 20, 30, 40, 50};
    int *p1 = NULL;
    int *p2 = NULL;
    printf(" func1 = %p\n",func1());
    p1 = func1();
    printf(" p1 = %p\n", p1);
    printf("*p1 = %d\n", *p1);

    printf(" func2 = %p\n",func2());
    p2 = func2();
    printf(" p2 = %p\n", p2);
    printf("*p2 = %d\n", *p2);
    return 0;
}
```

##### 测试结果

![18eKgI.png](https://s2.ax1x.com/2020/01/31/18eKgI.png)

如上图所示，在`func2`中有个`warning`：

```cpp
warning: function returns address of local variable [-Wreturn-local-addr]
     return &a;
            ^
```

即警告：函数返回局部变量的地址。在早期的编译过程中，初学者对局部变量地址进行返回经常导致`野指针满天飞`。现在的编译器对其做了优化，如上图所示：

* `func1`中`a`是`static int`类型的，`a`保存在全局区，程序执行完毕，这片内存区域才释放，所以不会触发警告，`p1`的指向也不会改变，是安全的。
* 而`func2`中`a`是`int`类型的，`a`保存在栈区，弹栈之后就没了，为了避免出现野指针，编译器自动将返回值指向`NULL`。

### 2.2 应用举例：局部变量

C语言中的局部变量是用栈来实现的。

* 我们在C语言中定义一个局部变量(如`int a`)时，编译器会在栈中**自动分配**一段空间`（32位机为4字节，64位为8字节）`给这个局部变量（分配时栈顶指针会移动给出空间，将`4（或8）`字节的栈内存地址和定义的局部变量名`a`给关联起来），对应的操作是**入栈**。

* 等函数退出的时候，局部变量要消亡，对应栈的操作是**弹栈（出栈）**。出栈时也是栈顶指针移动将栈空间中与`a`关联的那四个字节空间释放。这个动作是也自动的，无需程序员写代码干预。