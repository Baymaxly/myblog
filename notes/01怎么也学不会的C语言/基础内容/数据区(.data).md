---
title: 数据区(.data)
date: 2020-02-01 1:43:49
tags: 
 - C
 - 数据结构
 - 内存管理
#categories: 
#declare: true
---


## 一、三个常用段

编译器在编译程序的时候，将程序中的所有元素分成一些部分，各部分构成一个段，段是可执行程序的组成部分。

>1. 代码段：程序中的可执行部分，是由函数堆叠而成的
>2. 数据段(数据区、静态数据区、静态区)：程序中的数据，`C语言`中的**全局变量**（全局变量才算程序的数据，局部变量是函数的数据）
>3. `bss段`(`ZI段`（`zero initial`）)：被初始化为`0`，`bss段`本质上也是属于数据段。也就是说`bss段`就是被初始化为`0`的数据段。

本质上来说`.data`和`bss`都是用来存放`C程序`中的全局变量的。区别在于把显式初始化为非零的全局变量存放在`.data段`中，把显示初始化为`0`或没有显式初始化的全局变量存放在`bss段`中。（这也就是为什么`C语言`中未显式初始化的全局变量的值为默认为`0`）

## 二、代码段(.text)

除程序的可执行部分外，一些特殊类型的数据也会被存放在代码段

>1. `C语言`中定义的字符串常量
>2. `const型`常量：`C语言`中`const`关键字用来定义常量
>>* 在单片机的编译器中，将`cosnt`修饰的变量放在代码段实现无法被修改，这是绝对安全的
>>* 在`gcc`中，`const`型常量和普通变量一样被放在数据区，由编译器来检查以确保`const`型的常量不会被修改（其实是可以通过指针修改的）

### 测试代码

```cpp
#include <stdio.h>

int main(void)
{
    char *p = "WHUT2020";

    *(p + 6) = '1';
    *(p + 7) = '8';

    printf("p = %s\n", p);
    return 0;
}
```

### 测试结果

![data1.png](https://s2.ax1x.com/2020/02/01/1G6qXj.png)

在上述代码中，本意是想将`*p`替换为`WHUT2018`，却引发了段错误，这是因为**C语言中定义的字符串是一个常量，并不是变量**，是被放在代码段的，是不允许被修改的，实质上等同于`const char *p = "WHUT2020"`

## 三、数据段(.data)

数据段和堆内存几乎拥有完全相同的属性，只是生命周期不一样。数据段伴随程序一声，堆内存从`malloc`到`free`

>1. 显示初始化为非零的全局变量
>2. 静态局部变量（也就是`static`修饰的局部变量）
>>* 普通局部变量分配在栈上，静态局部变量分配在`.data`段

```cpp
#include <stdio.h>

int a = 10;//.data
void func(void)
{
    static int b = 10;//.data
    int c = 10;//栈
}
int main(void)
{
    return 0;
}
```

## 四、bss段

>1. 显式初始化为零的全局变量
>2. 未显式初始化的全局变量


## 五、样例

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*显示初始化的全局变量，储存在.data段*/
char str[] = "WHUT2018";

int main(void)
{
    /*局部变量，储存在栈上*/
    char str2[] = "WHUT2018";

    /*字符串常量，存储在代码段*/
    char *p1 = "WHUT2020";

    /*存储在malloc申请的堆内存中*/
    char *p2 = (char *)malloc(sizeof(str2));  
    if(！p2)
    {
        printf("MALLOC ERROR.\n");
        return -1;
    }
    memset(p2, 0, 10);
    strcpy(p2, "WHUT2018");
    free(p2);
}
```